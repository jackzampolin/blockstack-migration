'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEntropy = getEntropy;
exports.isWIF = isWIF;
exports.numberToEntropy = numberToEntropy;

require('core-js/shim');

var _crypto = require('crypto');

var _bs58check = require('bs58check');

var _bs58check2 = _interopRequireDefault(_bs58check);

var _bitcoinjsLib = require('bitcoinjs-lib');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getEntropy(numberOfBytes) {
  if (!numberOfBytes) {
    numberOfBytes = 32;
  }
  return (0, _crypto.randomBytes)(numberOfBytes);
}

function isWIF(privateKeyString) {
  var isValid = true;
  try {
    _bs58check2.default.decode(privateKeyString);
  } catch (e) {
    isValid = false;
  }
  return isValid;
}

function numberToEntropy(baseBuffer, index) {
  if (!(typeof index === 'undefined' ? 'undefined' : _typeof(index)) === 'number') {
    throw new Error('Index must be a number');
  }
  var indexHexString = index.toString(16);
  if (indexHexString.length % 2 === 1) {
    indexHexString = '0' + indexHexString;
  }
  var entropy = _bitcoinjsLib.crypto.sha256(Buffer.concat([baseBuffer, new Buffer(indexHexString, 'hex')]));
  return entropy;
}
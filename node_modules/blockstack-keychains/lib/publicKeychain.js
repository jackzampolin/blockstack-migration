'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PublicKeychain = undefined;

require('core-js/shim');

var _bitcoinjsLib = require('bitcoinjs-lib');

var _utils = require('./utils');

var _derivation = require('./derivation');

var _bip = require('bip39');

var _bip2 = _interopRequireDefault(_bip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PublicKeychain = exports.PublicKeychain = function () {
  function PublicKeychain(publicKey) {
    _classCallCheck(this, PublicKeychain);

    if (publicKey instanceof _bitcoinjsLib.ECPair) {
      this.ecPair = publicKey;
    } else if (publicKey instanceof Buffer) {
      this.ecPair = new _bitcoinjsLib.ECPair.fromPublicKeyBuffer(publicKey);
    } else {
      var publicKeyBuffer = new Buffer(publicKey, 'hex');
      this.ecPair = new _bitcoinjsLib.ECPair.fromPublicKeyBuffer(publicKeyBuffer);
    }
  }

  _createClass(PublicKeychain, [{
    key: 'publicKey',
    value: function publicKey(format) {
      var publicKeyBuffer = this.ecPair.getPublicKeyBuffer();
      if (!format) {
        return publicKeyBuffer;
      } else if (format === 'hex') {
        return publicKeyBuffer.toString('hex');
      } else {
        throw new Error('Format not supported');
      }
    }
  }, {
    key: 'address',
    value: function address() {
      return this.ecPair.getAddress();
    }
  }, {
    key: 'verify',
    value: function verify(message, signature) {
      var signatureBuffer = signature;
      if (!signature instanceof Buffer) {
        signatureBuffer = new Buffer(signature, 'hex');
      }
      return _bitcoinjsLib.message.verify(this.address(), signature, message);
    }
  }, {
    key: 'child',
    value: function child(entropy) {
      if (!entropy instanceof Buffer) {
        throw new Error('Entropy must be a buffer');
      }
      var childKeypair = (0, _derivation.getChildKeypair)(this.ecPair, entropy);
      return new PublicKeychain(childKeypair);
    }
  }, {
    key: 'publiclyEnumeratedChild',
    value: function publiclyEnumeratedChild(index) {
      var entropy = (0, _utils.numberToEntropy)(this.publicKey(), index);
      return this.child(entropy);
    }
  }, {
    key: 'publiclyNamedChild',
    value: function publiclyNamedChild(name) {
      if (name.length === 0) {
        throw new Error('Name must be at least one character long');
      }
      var entropy = _bitcoinjsLib.crypto.sha256(Buffer.concat([this.publicKey(), new Buffer(name)]));
      return this.child(entropy);
    }
  }]);

  return PublicKeychain;
}();
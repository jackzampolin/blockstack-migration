'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrivateKeychain = undefined;

require('core-js/shim');

var _bitcoinjsLib = require('bitcoinjs-lib');

var _bigi = require('bigi');

var _bigi2 = _interopRequireDefault(_bigi);

var _bip = require('bip39');

var _bip2 = _interopRequireDefault(_bip);

var _utils = require('./utils');

var _derivation = require('./derivation');

var _publicKeychain = require('./publicKeychain');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PrivateKeychain = exports.PrivateKeychain = function () {
  function PrivateKeychain(privateKey) {
    _classCallCheck(this, PrivateKeychain);

    if (!privateKey) {
      this.ecPair = new _bitcoinjsLib.ECPair.makeRandom({ rng: _utils.getEntropy });
    } else {
      if (privateKey instanceof _bitcoinjsLib.ECPair) {
        this.ecPair = privateKey;
      } else if (privateKey instanceof Buffer) {
        var privateKeyBigInteger = _bigi2.default.fromBuffer(privateKey);
        this.ecPair = new _bitcoinjsLib.ECPair(privateKeyBigInteger, null, {});
      } else if ((0, _utils.isWIF)(privateKey)) {
        this.ecPair = new _bitcoinjsLib.ECPair.fromWIF(privateKey);
      } else if (typeof privateKey === 'string') {
        var privateKeyBuffer = new Buffer(privateKey, 'hex'),
            privateKeyBigInteger = _bigi2.default.fromBuffer(privateKeyBuffer);
        this.ecPair = new _bitcoinjsLib.ECPair(privateKeyBigInteger, null, {});
      } else {
        throw new Error('Invalid private key format');
      }
    }
  }

  _createClass(PrivateKeychain, [{
    key: 'publicKeychain',
    value: function publicKeychain() {
      return new _publicKeychain.PublicKeychain(this.ecPair.getPublicKeyBuffer());
    }
  }, {
    key: 'privateKey',
    value: function privateKey(format) {
      var privateKeyBuffer = this.ecPair.d.toBuffer(32);
      if (!format) {
        return privateKeyBuffer;
      } else if (format === 'hex') {
        return privateKeyBuffer.toString('hex');
      } else {
        throw new Error('Format not supported');
      }
    }
  }, {
    key: 'mnemonic',
    value: function mnemonic() {
      return _bip2.default.entropyToMnemonic(this.privateKey('hex'));
    }
  }, {
    key: 'wif',
    value: function wif() {
      return this.ecPair.toWIF();
    }
  }, {
    key: 'sign',
    value: function sign(message) {
      return _bitcoinjsLib.message.sign(this.ecPair, message);
    }
  }, {
    key: 'child',
    value: function child(entropy) {
      if (!entropy instanceof Buffer) {
        throw new Error('Entropy must be a buffer');
      }
      var childKeypair = (0, _derivation.getChildKeypair)(this.ecPair, entropy);
      return new PrivateKeychain(childKeypair);
    }
  }, {
    key: 'privatelyEnumeratedChild',
    value: function privatelyEnumeratedChild(index) {
      var entropy = (0, _utils.numberToEntropy)(this.privateKey(), index);
      return this.child(entropy);
    }
  }, {
    key: 'privatelyNamedChild',
    value: function privatelyNamedChild(name) {
      if (name.length === 0) {
        throw new Error('Name must be at least one character long');
      }
      var entropy = _bitcoinjsLib.crypto.sha256(Buffer.concat([this.privateKey(), new Buffer(name)]));
      return this.child(entropy);
    }
  }], [{
    key: 'fromMnemonic',
    value: function fromMnemonic(mnemonic) {
      var privateKey = _bip2.default.mnemonicToEntropy(mnemonic);
      return new PrivateKeychain(privateKey);
    }
  }]);

  return PrivateKeychain;
}();